<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
<style>
/*
Simple div with a border
that is centered to its parent element.
Height and width are equal for now.
Later will allow this to scale down or up while
maintaining a sprite
*/

.PromptInput{
margin:0px auto;
display:inline-block;
width:100%;
}

.Text{
font-family:Luminari, cursive;
display:inline;
}

.TextArea{
width:80%;
height:2.5vw;
font-size:2vw;
}

.EnterRow{
margin:0px auto;
margin-left:28%;
width:50%;
}

.CenterH1{
	margin: 10px auto;
	display:table;
	font-family:Luminari, cursive;
}

.Center{
	margin: 0px auto;
	width:200px;
	height:200px;
	display:table;
	border:2px solid purple;
}

.Row{
	width:100%;
	height:auto;
	display:table-row;
	border:3px solid green;
}

.Column{
	width:1%;
	text-align:center;
	display:table-cell;
	border:1px solid black;
}

</style>
<script type="text/javascript">

function ForceEvent(E,T){
	if ("createEvent" in document) {
	    var evt = document.createEvent("HTMLEvents");
	    evt.initEvent(T, false, true);
	    E.dispatchEvent(evt);
	}
}

function Text(Value){
	var Text = document.createElement("text");
	Text.className="Text";
	Text.innerHTML = Value;
	return Text;
}

function TableD(V,N){
	//if(V!=null){
	var td = document.createElement("td");
	
	if(V){
		td.appendChild(V);
		td.id = "TD"+V.id;
	}
	
	if(N)
		td.innerHTML = N;
	
	return td;
	//}
}

function InputPrompt2(Text){
	
	var PI = document.createElement("div");
	PI.className="PromptInput";
	
	var TA = document.createElement("textarea");
	TA.className="TextArea";
	
	PI.appendChild(Text);
	
	PI.appendChild(TA);
	
	return [PI,TA];
	
}

function ArraysNotEqual(A1,A2){
	if(A1.length!=A2.length)
		return true;
	
	for(var i=0; i<A1.length && i<A2.length;i+=1)
		for(var j=0; j<A1[i].length && j<A2[i].length;j+=1){
			if(A1[i].length!=A2[i].length ||
					A1[i][j]==A2[i][j])
				return true;
		}
	
	return false;
}

function CreateAsyncFunctions(Options){
	if(Options==null)
		return;
	if(Options.length<5){
		alert("Be wary of using this function recklessly...");
		return;
	}
	
	/*
	 * Options [[func1,Params,LogicFunction,MaxLife,Duration,AfterFunc],....,]
	 * LOGIC function takes all parameters...
	 * starting with MaxLife,Interval,Adder
	 * then add on any more parameters to logic func
	 * When lifecycle of async function is finished, 
	 	if AfterFunc exists, call this. 
	 	This is a callback from the async function,
	 	Can be chained indefinitely
	 */
	for(var i=0; i<Options.length;i+=1){
		
		var Func = Options[i][0];
		var Params = Options[i][1];
		var LogicFunction = Options[i][2];
		var MaxLife = Options[i][3];
		var Interval = 0;
		var Duration = Options[i][4];
		var AfterFunc  = undefined;
		if(Options[i].length>5)
			AfterFunc = Options[i][5];
		
		if(Duration<=0 || Params==null)
			return;
		
		(function(Params,LogicFunction,MaxLife,Interval,Duration){
			//Closure
			Time = function(){
				
			//console.log("FUNCTION IN ACTION");	
				
			Interval+=Duration * Math.random();
			
			var Ret;
			
			Ret = Func(Params);
			
			//console.log(Ret+">>"+Interval+">>"+MaxLife);
			
			var X = true;
			
			//Logic if exists
			if(LogicFunction)
				X = LogicFunction([MaxLife,Interval,Duration].concat(Params));
			
			//Logic Func not exist
			if(X==true){
				
				//console.log(Interval+">>"+MaxLife);
				
				//Commit STILL to the time
				if(Interval<=MaxLife)
				 setTimeout(Time, Duration*Math.random());
				else{
				
					if(AfterFunc!=null)
						AfterFunc();
					
					return;
				}
				 
				
			}
			else{
				
				if(AfterFunc!=null)
					AfterFunc();
				return;
				
				}
			
			}
			
			Time();
		
		})(Params,LogicFunction,MaxLife,Interval,Duration);
		
		
	}
	
}

function ValidCoords(S){
	if(S.length==2){
		if(! isNaN(parseInt(S[0])) && !isNaN(parseInt(S[1]))
				){
			console.log(S+" is valid");
		
			//IF Sprite1 is active...
			//Move it
			return true;
			
		}
		else{
			console.log(S+" is not valid");
		}
	}
	else{
		console.log(S+" is not valid");
	}
	return false;
}

//Set the type of empty space that you want
//Size may vary, but percentage taken will be consistent
//underscore was the best that I could find that is consistent
//So I will keep this here as the default
var EmptySpace = "_";


var Sprite1;

//Since a character takes up a const space in column, 
//This is not needed
//Zoom feature should increase the number of elements
//var ColumnWidth;

//code representation of the grid
//This can point DYNAMICALLY to each column element
//Or access each column element by its id
//Which is in format R,C -> Row,Column
var ASCIIGRID = [];

function AddRow(Grid){
	var Row = document.createElement("div");
	Row.className="Row";
	if(Grid){
		Grid.appendChild(Row);
		return Row;
	}
	else
		console.log("No Grid ELEMENT given");
}

//Add a column to a row
//Initial value is set 
function AddColumn(Row){
	var Column = document.createElement("span");
	Column.className="Column";
	
	var T = Text(EmptySpace);
	
	Column.appendChild(T);
	
	if(Row){
		Row.appendChild(Column);
		return Column;	
	}
	else
		console.log("No Row ELEMENT Given!!");
}

//Create grid with height,width,precision
//Precision should be in the range of 1 -> inf
// Precision is just a multiplier to the 
//width and height
function CreateGrid(Height,Width,Precision){
	if(Height<=0 || Width<=0 || 
			(Precision<=0 && Precision)){
		console.log("INVALID CREATE GRID, see comments");
		return undefined;
	}
	else if(Precision){
		Height*=Precision;
		Width*=Precision;
	}
	
	var Center;
	var Centers = document.getElementsByClassName("Center");
	if(Centers.length>0){
		//Choosing first one that exists...
		Center = Centers[0];
	}
	else{
		Center = document.createElement("div");
		Center.className="Center";
	}
	
	//Do you want to increase the entire GRID
	//Or just decreate text
	Center.style.height = Height;
	Center.style.width = Width;
	
	document.body.appendChild(Center);
	
	//First Push a new Row element to Center div
	
	//Then push a new Column element to Row div
	//Set column element id to i,j
	//Push the column element to ASCIIGRID
	
	for(var i=0; i<Height;i++){
		
		var Row = AddRow(Center);
		if(!Row)
			{
				console.log("ERROR ADDING ROW (CreateGrid)["+i+","+j+"]");
				return null;
			}
		
		ASCIIGRID.push([]);
		
		for(var j=0; j<Width;++j){
			
			var Column = AddColumn(Row);
			if(!Column)
			{
				console.log("ERROR ADDING COLUMN (CreateGrid)["+i+","+j+"]");
				return null;
			}
			
			Column.id=i+","+j;
			
			var PrevFontSize = parseInt(Column.style.fontSize);
			Column.style.fontSize = ((PrevFontSize)/Precision)+"px";
			
			ASCIIGRID[i].push(Column);
			
		}	
	}
	
	
	return Center;
}

//Closure
//SubASCIIGrid is basically a grid element
//Which is a 2D array
//EX:
/*
 * 
 [
  ["S","P","A","C"],
  ["I","N","G",""] 	 
 ]
  // any string that is invalid will be replaces with the default
  // EmptySpace
 
 */
 
 function ClearTable(){
	var Table = document.getElementsByClassName("Center")[0];
	var Rows = Table.childNodes;
	for(var i=0; i<Rows.length;i+=1)
		{
		var Columns = Rows[i].childNodes;
		for(var j=0; j<Columns.length;j+=1){
			
			UpdateValue(Columns[j].childNodes[0],EmptySpace);
			
		}
		
		}
}
 
 function UpdateValue(E,V){
	var Parent = E.parentNode;
	Parent.removeChild(E);
	Parent.appendChild(Text(V));
}
 
//But instead of storing elements, this stores ASCII values
//Can be as small as one element to as large as the grid
//PivitPosition is the position in which the topleft-most
//ASCII character of SubASCIIGrid will be placed INITIALLY on the
//ASCIIGRID, [R,C] format
//but.... if R and C is negative, that is OK!
//Upon animation, it will check if the point in the sprite CAN exist
//on grid, and if it can, then display it
// EX: if(document.getElementById(i+","+j)!=null) then populate
//and replace previous position with EmptySpace var

//Delay is time it will take to transition from point to point
//This is in milliseconds!
//A collection of transitions is what comprises the animation
function Sprite(PivotPosition,SubASCIIGrid,Delay) {
	if(!PivotPosition){
		console.log("SPRITE--No Pivot Position");
		return;
	}
	if(PivotPosition.length!=2){
		console.log("SPRITE--Invalid Pivot Position");
		return;
	}
	if(!SubASCIIGrid){
		console.log("SPRITE--No SUB ASCII GRID");
		return;
	}
	if(!Delay || Delay<0){
		console.log("Invalid Delay");
		return;
	}
	
	//Private Function for pretty print when initializing
	function PrettyPrintASCIIGrid(AG){
		for(var i=0; i<AG.length;i+=1){
			//for(var j=0; j<AG[i].length;j+=1){
				console.log(AG[i]);
			//}
			//console.log();
		}
	}
	
	function GetASCIIGridLengths(){
		var AG = document.getElementsByClassName("Center")[0]
		var AR = document.getElementsByClassName("Row")[0];
		console.log("ASCII GRID LENGTHS:"+[AG.childNodes.length,AR.childNodes.length]);
		return [AG.childNodes.length,AR.childNodes.length];
	}
	
	function SetOffset(PivotPosition,ASCIIGRID){
		//Only need an offset if out of bounds in negative direction
		var Offset = [0,0];
		
		if(PivotPosition[0]<0){
			Offset[0] = (ASCIIGRID.length) +
			PivotPosition[0];
		}
		else if( PivotPosition[0]>=ASCIIGRID.length){
			Offset[0] = (ASCIIGRID.length-1) -
			PivotPosition[0];
		}
		if(PivotPosition[1]<0){
			Offset[1] = (ASCIIGRID[0].length) +
			PivotPosition[1];
		}
		else if(PivotPosition[1]>=ASCIIGRID[0].length){
			Offset[1] = (ASCIIGRID[0].length-1) -
			PivotPosition[1];
		}
		
		return Offset;
	}
	
	//Use pivot position as reference
	// [[E,Y,X],...,]
	this.SetAllPositions = function (){
		
		var Offset = SetOffset(this.PivotPosition,ASCIIGRID);
		
		var R = 0;
	
		var Positions = [];
		
		var AGLengths = GetASCIIGridLengths();
		
		for(var i=this.PivotPosition[0]+Offset[0];
		R<this.ASCIIGRID.length
		&& i<AGLengths[0]+Offset[0];i+=1,R+=1){
			
			var C = 0;
			
			for(var j=this.PivotPosition[1]+Offset[1]; 
			C<this.ASCIIGRID[R].length && 
			j<AGLengths[1]+Offset[1];j+=1,C+=1
			){
				
				var FullKey = R+","+C;
				var RelativeKey = i+","+j;
				var E = document.getElementById(FullKey);
				Positions.push([E,FullKey,RelativeKey]);
				
			}
		}
		
		console.log("ALL POSITIONS:"+Positions);
		
		return Positions;
		
	}
	
	//Create 2D list of all Previous positions by iterating
	//ASCIIGRID and keeping less than that and my sub grid together
	//And also set the previous positions to EmptySpace
	
	//Then Starting From Pivot Position, first translate this
	//Then translate all other positions based off of Difference
	//neighbors
	this.TranslateAll = function (Difference){
		
		console.log("TRANSLATE ALL BY DIFFERENCE:"+Difference);
		
		var Key;
		
		var Offset = SetOffset(this.PivotPosition,ASCIIGRID);
		
		console.log("OFFSET:"+Offset);
		
		//Create List of next positions
		var NextPositions = [];
		
		for(var i=0; 
		i<this.AllPivotPositions.length;i+=1){
			var E = this.AllPivotPositions[i][0];
			
			var S = this.AllPivotPositions[i][1].split(",");
			var S2 = this.AllPivotPositions[i][2].split(",");
			
			var I = parseInt(S[0]) +Difference[0];
			var J = parseInt(S[1]) +Difference[1];
			
			var I2 = parseInt(S2[0]);
			var J2 = parseInt(S2[1]);
			
			NextPositions.push([E,I+","+J,I2+","+J2]);
		}
		
		console.log("NEXT POSITIONS:"+NextPositions);
		
		for(var i=0; i<NextPositions.length;i+=1){
			var Prev = 
				NextPositions[i][0].childNodes[0];
			
			var S = NextPositions[i][1].split(",");
			
			var I = parseInt(S[0]);
			var J = parseInt(S[1]);
			
			var Next = document.getElementById(I+","+J).childNodes[0];
			
			var Relative = NextPositions[i][2].split(",");
			var Value = Prev.innerHTML;
			
			UpdateValue(Prev.childNodes[0],EmptySpace);
			
			var I2 = parseInt(Relative[0]);
			var J2 = parseInt(Relative[1]);
			
			console.log("ACCESS:"+I2+","+J2);
			
			UpdateValue(Next.childNodes[0],
			this.ASCIIGRID
			[I2]
			[J2]	
			);
			
		}
		
		this.AllPivotPositions = this.SetAllPositions();
		
	}
	
	
	
	//Private Static Function
	function ComputeDifference(P1,P2){
		return [P2[0]-P1[0],P2[1]-P1[1]];
	}
	
	// Private Static Vars are vars without this
	var PrivateVar1;
	
	//Otherwise they are public	
	//Pivot Position will be updates every transition
	this.PivotPosition = PivotPosition;
	this.ASCIIGRID = SubASCIIGrid;
	this.AllPivotPositions = this.SetAllPositions();
	
	//Public function callable from object Sprite
	//Translation Function from here to there
	//ex if translate from [0,0] to [10,20],
	//You will need to ComputeDifference(P1,P2)
	//Then, with this info, loop through all sprite pixels
	//
	this.Translate = function(P2){
		if(!P2)
			{
			return;
			}
		if(P2.length!=2)
			return;
		

		console.log("Translate");
		
		var Difference = ComputeDifference(this.PivotPosition,P2);
		
		//Now use async func
		//which waits by the delay set
		//and then calls TranslateAll
		//starts at pivot
		
		this.TranslateAll(Difference);
	}
	
	console.log("Starting Position: "+this.PivotPosition);
	console.log("SUB ASCII GRID: ");
	PrettyPrintASCIIGrid(this.ASCIIGRID)
	    
	//this.Translate(this.PivotPosition);
	
	};
</script>
</head>
<body>
<h1 class="CenterH1">ASCII ART ANIMATION</h1>

<!-- Table row maximizes all children of row  -->
<!--
<div class="Row">
<div class="Column" style="font-size:12px;">_</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
</div>
-->

<script type="text/javascript">

var Height = 20;
var Width = 40;

//Approximately, for every 1px in height, add 2 px in width
CreateGrid(Height,Width,1);

var Row = document.createElement("table");
Row.className="EnterRow";
var EnterCoordinates = InputPrompt2(
		Text("Enter Coordinates y,x"));
var TR1 = document.createElement("tr");
TR1.appendChild(TableD(EnterCoordinates[0]));
Row.appendChild(TR1);

var EnterSprite = InputPrompt2(
		Text("Enter 2D Sprite Array [['X',..,],..,[]]"));
//var TR2 = document.createElement("tr");
TR1.appendChild(TableD(EnterSprite[0]));
Row.appendChild(TR1);

document.body.appendChild(Row);
EnterCoordinates[1].addEventListener("input",function(){
	var S = this.value.split(",");
	
	ClearTable();
	
	if(ValidCoords(S)==true){
		if(Sprite1){
			Sprite1.Translate(S);
		}
		ForceEvent(document.getElementsByTagName("textarea")[1],"input");
	}
	
});

EnterSprite[1].style.height="300px";
EnterSprite[1].style.fontSize="1.5vw";

EnterSprite[1].addEventListener("input",function(){
	var Array;
	//try{
	Array = eval(this.value);
	Array.push();
	console.log("ARRAY:"+Array);
	
	//Sprite1 = new Sprite([])
	
	
	var Coords = document.getElementsByTagName("textarea")[0].value.split(",");
	
	if(ValidCoords(Coords)==true){
		
		
		var Sprite2 = new Sprite(Coords,Array,500);
		
		if(Sprite1==null){
			//alert("New Sprite");
			Sprite1 = new Sprite(Coords,Array,500);
		}
		else if(ArraysNotEqual(Sprite1.ASCIIGRID,Sprite2.ASCIIGRID)==true){
			//alert("New Sprite");
			Sprite1=Sprite2;
		}
		else{
			ClearTable();
			console.log("NOT UNIQUE: "+Sprite1.ASCIIGRID+"=="+Sprite2.ASCIIGRID);
		}
	}
	
	//ForceEvent(document.getElementsByClassName[0],"input");
	
	//}
	//catch(e){
		//console.log(e+" Invalid ARRAY:"+this.value.split("\n").join(""));
	//}
});

//Some testing
document.getElementById("5,5").innerHTML="a";

//var 

Sprite1 = new Sprite([0,0],[
["*","","*"],
["","*",""],
["*","","*"]
],500);

//Sprite1.Translate([5,5]);

</script>
</body>
</html>