<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
<style>
/*
Simple div with a border
that is centered to its parent element.
Height and width are equal for now.
Later will allow this to scale down or up while
maintaining a sprite
*/

.PromptInput{
margin:0px auto;
display:inline-block;
width:100%;
}

.Text{
font-family:Luminari, cursive;
display:inline;
}

.TextArea{
width:80%;
height:2.5vw;
font-size:2vw;
}

.EnterRow{
margin:0px auto;
margin-left:28%;
width:50%;
}

.CenterH1{
	margin: 10px auto;
	display:table;
	font-family:Luminari, cursive;
}

.Center{
	margin: 0px auto;
	width:200px;
	height:200px;
	display:table;
	border:2px solid purple;
}

.Row{
	width:100%;
	height:auto;
	display:table-row;
	border:3px solid green;
}

.Column{
	width:1%;
	text-align:center;
	display:table-cell;
	border:1px solid black;
}

</style>
<script type="text/javascript">

function ForceEvent(E,T){
	if ("createEvent" in document) {
	    var evt = document.createEvent("HTMLEvents");
	    evt.initEvent(T, false, true);
	    E.dispatchEvent(evt);
	}
}

function Text(Value){
	var Text = document.createElement("text");
	Text.className="Text";
	Text.innerHTML = Value;
	return Text;
}

function TableD(V,N){
	//if(V!=null){
	var td = document.createElement("td");
	
	if(V){
		td.appendChild(V);
		td.id = "TD"+V.id;
	}
	
	if(N)
		td.innerHTML = N;
	
	return td;
	//}
}

function TableR(E,V){
	//if(V!=null){
	var tr = document.createElement("tr");
	tr.appendChild(TableD(E,V));
	return tr;
}

function SelectionPrompt(Name,Options){
	var Select = document.createElement("select");
	Select.id=Name;
	var OptGroup = document.createElement("optgroup");
	Select.appendChild(OptGroup);
	for(var i=0; i<Options.length;i+=1){
		var Option = document.createElement("option");
		Option.innerHTML = Options[i];
		OptGroup.appendChild(Option);
	}
	return [Select,OptGroup];
}
	
function InputPrompt2(Text){
	
	var PI = document.createElement("div");
	PI.className="PromptInput";
	
	var TA = document.createElement("textarea");
	TA.className="TextArea";
	
	PI.appendChild(Text);
	
	PI.appendChild(TA);
	
	return [PI,TA];
	
}

function ArraysNotEqual(A1,A2){
	if(A1.length!=A2.length)
		return true;
	
	for(var i=0; i<A1.length && i<A2.length;i+=1)
		for(var j=0; j<A1[i].length && j<A2[i].length;j+=1){
			if(A1[i].length!=A2[i].length ||
					A1[i][j]!=A2[i][j])
				return true;
		}
	
	return false;
}

function CreateAsyncFunctions(Options){
	if(Options==null)
		return;
	
	
	/*
	 * Options [[func1,Params,LogicFunction,MaxLife,Duration,AfterFunc],....,]
	 * LOGIC function takes all parameters...
	 * starting with MaxLife,Interval,Adder
	 * then add on any more parameters to logic func
	 * When lifecycle of async function is finished, 
	 	if AfterFunc exists, call this. 
	 	This is a callback from the async function,
	 	Can be chained indefinitely
	 */
	for(var i=0; i<Options.length;i+=1){
		
		if(Options[i].length<5){
			alert("Be wary of using this function recklessly...");
			return;
		}
		
		var Func = Options[i][0];
		var Params = Options[i][1];
		var LogicFunction = Options[i][2];
		var MaxLife = Options[i][3];
		var Interval = 0;
		var Duration = Options[i][4];
		var AfterFunc  = undefined;
		if(Options[i].length>5)
			AfterFunc = Options[i][5];
		
		if(Duration<=0 || Params==null)
			return;
		
		(function(Params,LogicFunction,MaxLife,Interval,Duration){
			//Closure
			Time = function(){
				
			//console.log("FUNCTION IN ACTION");	
				
			Interval+=Duration; //* Math.random();
			
			var Ret;
			
			Ret = Func(Params);
			
			//console.log(Ret+">>"+Interval+">>"+MaxLife);
			
			var X = true;
			
			//Logic if exists
			if(LogicFunction)
				X = LogicFunction([MaxLife,Interval,Duration].concat(Params).concat(Ret));
			
			//Logic Func not exist
			if(X==true){
				
				//console.log(Interval+">>"+MaxLife);
				
				//Commit STILL to the time
				if(Interval<=MaxLife)
				 setTimeout(Time, Duration);
				else{
				
					if(AfterFunc!=null)
						AfterFunc();
					
					return;
				}
				 
				
			}
			else{
				
				if(AfterFunc!=null)
					AfterFunc();
				return;
				
				}
			
			}
			
			Time();
		
		})(Params,LogicFunction,MaxLife,Interval,Duration);
		
		
	}
	
}

function ValidCoords(S){
	if(S.length==2){
		if(! isNaN(parseInt(S[0])) && !isNaN(parseInt(S[1]))
				){
			console.log(S+" is valid");
		
			//IF Sprite1 is active...
			//Move it
			return true;
			
		}
		else{
			console.log(S+" is not valid");
		}
	}
	else{
		console.log(S+" is not valid");
	}
	return false;
}

//Set the type of empty space that you want
//Size may vary, but percentage taken will be consistent
//underscore was the best that I could find that is consistent
//So I will keep this here as the default
var EmptySpace = "_";


var Sprite1;

//Since a character takes up a const space in column, 
//This is not needed
//Zoom feature should increase the number of elements
//var ColumnWidth;

//code representation of the grid
//This can point DYNAMICALLY to each column element
//Or access each column element by its id
//Which is in format R,C -> Row,Column
var ASCIIGRID = [];

function AddRow(Grid){
	var Row = document.createElement("div");
	Row.className="Row";
	if(Grid){
		Grid.appendChild(Row);
		return Row;
	}
	else
		console.log("No Grid ELEMENT given");
}

//Add a column to a row
//Initial value is set 
function AddColumn(Row){
	var Column = document.createElement("span");
	Column.className="Column";
	
	var T = Text(EmptySpace);
	
	Column.appendChild(T);
	
	if(Row){
		Row.appendChild(Column);
		return Column;	
	}
	else
		console.log("No Row ELEMENT Given!!");
}

//Create grid with height,width,precision
//Precision should be in the range of 1 -> inf
// Precision is just a multiplier to the 
//width and height
function CreateGrid(Height,Width,Precision){
	if(Height<=0 || Width<=0 || 
			(Precision<=0 && Precision)){
		console.log("INVALID CREATE GRID, see comments");
		return undefined;
	}
	else if(Precision){
		Height*=Precision;
		Width*=Precision;
	}
	
	var Center;
	var Centers = document.getElementsByClassName("Center");
	if(Centers.length>0){
		//Choosing first one that exists...
		Center = Centers[0];
	}
	else{
		Center = document.createElement("div");
		Center.className="Center";
	}
	
	//Do you want to increase the entire GRID
	//Or just decreate text
	Center.style.height = Height;
	Center.style.width = Width;
	
	document.body.appendChild(Center);
	
	//First Push a new Row element to Center div
	
	//Then push a new Column element to Row div
	//Set column element id to i,j
	//Push the column element to ASCIIGRID
	
	for(var i=0; i<Height;i++){
		
		var Row = AddRow(Center);
		if(!Row)
			{
				console.log("ERROR ADDING ROW (CreateGrid)["+i+","+j+"]");
				return null;
			}
		
		ASCIIGRID.push([]);
		
		for(var j=0; j<Width;++j){
			
			var Column = AddColumn(Row);
			if(!Column)
			{
				console.log("ERROR ADDING COLUMN (CreateGrid)["+i+","+j+"]");
				return null;
			}
			
			Column.id=i+","+j;
			
			var PrevFontSize = parseInt(Column.style.fontSize);
			Column.style.fontSize = ((PrevFontSize)/Precision)+"px";
			
			ASCIIGRID[i].push(Column);
			
		}	
	}
	
	
	return Center;
}

//Closure
//SubASCIIGrid is basically a grid element
//Which is a 2D array
//EX:
/*
 * 
 [
  ["S","P","A","C"],
  ["I","N","G",""] 	 
 ]
  // any string that is invalid will be replaces with the default
  // EmptySpace
 
 */
 
 function NotClear(){
	 var Table = document.getElementsByClassName("Center")[0];
		var Rows = Table.childNodes;
	
	 for(var i=0; i<Rows.length;i+=1)
		{
		var Columns = Rows[i].childNodes;
		for(var j=0; j<Columns.length;j+=1){
			
			//UpdateValue(Columns[j].childNodes[0],EmptySpace);
			
			if(Columns[j].childNodes[0].innerHTML!=EmptySpace)
				return true;
			
		}
		
		}
	
	return false;
}
 
 
 
 function UpdateValue(Parent,E,V){
	//var Parent = E.parentElement;
	
	console.log("UPDATE VALUE:"+E.innerHTML+" TO:"+V);
	
	//Parent.removeChild(E);
	
	//E.parentNode.removeChild(E);
	
	if(Parent){
	Parent.innerHTML = "";
	
	Parent.appendChild(Text(V));
	}
	//while(Parent.childNodes.length==0){
		
	//}
	
}
 
 function ClearTable(){
		var Table = document.getElementsByClassName("Center")[0];
		var Rows = Table.childNodes;
		
		do{
		
		for(var i=0; i<Rows.length;i+=1)
			{
			var Columns = Rows[i].childNodes;
			for(var j=0; j<Columns.length;j+=1){
				
				UpdateValue(Columns[j],Columns[j].childNodes[0],EmptySpace);
				
			}
			
			}
		
		}while(NotClear());
	}
 
//But instead of storing elements, this stores ASCII values
//Can be as small as one element to as large as the grid
//PivitPosition is the position in which the topleft-most
//ASCII character of SubASCIIGrid will be placed INITIALLY on the
//ASCIIGRID, [R,C] format
//but.... if R and C is negative, that is OK!
//Upon animation, it will check if the point in the sprite CAN exist
//on grid, and if it can, then display it
// EX: if(document.getElementById(i+","+j)!=null) then populate
//and replace previous position with EmptySpace var

//Delay is time it will take to transition from point to point
//This is in milliseconds!
//A collection of transitions is what comprises the animation
function Sprite(PivotPosition,SubASCIIGrid,Delay) {
	if(!PivotPosition){
		console.log("SPRITE--No Pivot Position");
		return;
	}
	if(PivotPosition.length!=2){
		console.log("SPRITE--Invalid Pivot Position");
		return;
	}
	if(!SubASCIIGrid){
		console.log("SPRITE--No SUB ASCII GRID");
		return;
	}
	if(!Delay || Delay<0){
		console.log("Invalid Delay");
		return;
	}
	
	//Private Function for pretty print when initializing
	function PrettyPrintASCIIGrid(AG){
		for(var i=0; i<AG.length;i+=1){
			//for(var j=0; j<AG[i].length;j+=1){
				console.log(AG[i]);
			//}
			//console.log();
		}
	}
	
	function Heuristic(P1,P2){
		
	}
	
	function NotOverwriteNext(PrevPosition,NextPositions){
		
		for(var i=0; i<NextPositions.length;i+=1){
			var NextPosition = NextPositions[i][1].split(",");
			
			console.log(PrevPosition+"=="+NextPosition+" ??");
			
			if(parseInt(NextPosition[0])==
				parseInt(PrevPosition[0]) &&
					parseInt(NextPosition[1])==
						parseInt(PrevPosition[1])){
				console.log("CANNOT OVERWRITE:"+NextPosition);
				return false;	
			}
		}
		console.log("CAN OVERWRITE:"+PrevPosition);
		return true;
	}
	
	function GetASCIIGridLengths(){
		var AG = document.getElementsByClassName("Center")[0]
		var AR = document.getElementsByClassName("Row")[0];
		console.log("ASCII GRID LENGTHS:"+[AG.childNodes.length,AR.childNodes.length]);
		return [AG.childNodes.length,AR.childNodes.length];
	}
	
	function SetOffset(PivotPosition,ASCIIGRID){
		//Only need an offset if out of bounds in negative direction
		var Offset = [0,0];
		
		if(PivotPosition[0]<0){
			Offset[0] = (ASCIIGRID.length) +
			PivotPosition[0];
		}
		else if( PivotPosition[0]>=ASCIIGRID.length){
			Offset[0] = (ASCIIGRID.length-1) -
			PivotPosition[0];
		}
		if(PivotPosition[1]<0){
			Offset[1] = (ASCIIGRID[0].length) +
			PivotPosition[1];
		}
		else if(PivotPosition[1]>=ASCIIGRID[0].length){
			Offset[1] = (ASCIIGRID[0].length-1) -
			PivotPosition[1];
		}
		
		return [parseInt(Offset[0]),parseInt(Offset[1])];
	}
	
	//Use pivot position as reference
	// [[E,Y,X],...,]
	this.SetAllPositions = function (){
		
		var Offset = SetOffset(this.PivotPosition,ASCIIGRID);
	
		var Positions = [];
		
		var AGLengths = GetASCIIGridLengths();
		
		for(var i=parseInt(this.PivotPosition[0])+(Offset[0]),
			R = 0;
		R<this.ASCIIGRID.length
		&& i<AGLengths[0]+Offset[0];i+=1,R+=1){
			
			for(var j=parseInt(this.PivotPosition[1])+Offset[1],
				C=0; 
			C<this.ASCIIGRID[R].length && 
			j<AGLengths[1]+Offset[1];j+=1,C+=1
			){
				
				var FullKey = i+","+j;
				var RelativeKey =  R+","+C;
				//console.log("RelativeKey:"+RelativeKey);
				var E = document.getElementById(FullKey);
				Positions.push([E,FullKey,RelativeKey]);
				
			}
		}
		
		console.log("ALL POSITIONS:"+Positions);
		
		return Positions;
		
	}
	
	this.TranslateByRow = function(Difference,Callback,This){
		 
		if(this.AVAILABLE==true){
		this.AVAILABLE==false;
		//Ignore Difference of column
		//Difference[1] = 0;
	   
		CreateAsyncFunctions([
			[
				//This function WILL increment position given by 1
				//Then return
				function(Params){
					var IDX = 0;	
					console.log("PARAMS:"+Params);
					var Difference = Params[0];
					var SubDifference = 
						(Difference[IDX]==0?[0,0]:(Difference[IDX]>0?
						[1,0]:[-1,0]));
					return SubDifference;
				}
				,
				[Difference,this]
				,
				//Logic function takes diff and subdiff
				//Subtract diff by subdiff
				function(Params){
					var IDX = 0;
					console.log("PARAMS2:"+Params);
					var SubDifference = [Params[Params.length-2],
						Params[Params.length-1]];
					
					SubDifference[IDX] *= (parseInt(Params[1])/parseInt(Params[2]));
					
					//console.log("SUB DIFF:"+SubDifference);
					
					//console.log("SD:"+SubDifference);
					var Difference = Params[Params.length-4];
					
					//MAY BE A CONDITIONAL HERE
					if(document.getElementById("Select Movement Type").
							value.toLowerCase()=="column->row")
							SubDifference[1] = Difference[1];
					
					
					console.log("SUB DIFF:"+SubDifference);
					var This = Params[Params.length-3];
					
					if(SubDifference[IDX]<0){
						if(SubDifference[IDX]>=Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							return true;
						}
						else
							return false;
					}
					else if(SubDifference[IDX]>=0){
						if(SubDifference[IDX]<Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							return true;
						}
						//else
							//return false;
					}
				}
				
				,
				
				//This should be MAX time it will take!
				this.Delay*(Difference[0]<=0? Difference[0]*-1:Difference[0]),
				
				this.Delay,
				
				function(){
					console.log("FINISHED ANIMATION BY ROW FOR SPRITE");
					This.AVAILABLE=true;
					Callback(This);
				}
				
			]
		]);
		}
	};
	
	this.TranslateByColumn = function(Difference,Callback,This){
		 
		//Ignore Difference of column
		//Difference[0] = 0;
	   
		CreateAsyncFunctions([
			[
				//This function WILL increment position given by 1
				//Then return
				function(Params){
					var IDX = 1;	

				    console.log("PARAMS:"+Params);
					var Difference = Params[0];
					var SubDifference = 
						(Difference[IDX]==0?[0,0]:(Difference[IDX]>0?
						[0,1]:[0,-1]));
					return SubDifference;
				}
				,
				[Difference,this]
				,
				//Logic function takes diff and subdiff
				//Subtract diff by subdiff
				function(Params){
					var IDX = 1;
				    console.log("PARAMS2:"+Params);
					var SubDifference = [Params[Params.length-2],
						Params[Params.length-1]
						];
					
					SubDifference[IDX] *= (parseInt(Params[1])/parseInt(Params[2]));
					
					//console.log("SD:"+SubDifference);
					var Difference = Params[Params.length-4];
					
					
					//MAY BE A CONDITIONAL HERE
					if(document.getElementById("Select Movement Type").
							value.toLowerCase()=="row->column")
							SubDifference[0] = Difference[0];
					
					//
					
					
					console.log("DIFF:"+Difference);
					
					console.log("SUBDIFF:"+SubDifference);
					
					var This = Params[Params.length-3];
					
					if(SubDifference[IDX]<0){
						if(SubDifference[IDX]>=Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							//Difference[IDX]-=1;
							
							return true;
						}
						else
							return false;
					}
					else if(SubDifference[IDX]>=0){
						if(SubDifference[IDX]<=Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							//Difference[IDX]+=1;
							
							return true;
						}
						
					}
				}
				
				,
				
				this.Delay*(Difference[1]<=0? Difference[1]*-1:Difference[1]),
				
				this.Delay,
				
				function(){
					console.log("FINISHED ANIMATION BY COLUMN FOR SPRITE");
					
					Callback(This);
				
				}
				
			]
		]);
	};
	
	this.TranslateByBoth = function(Difference,Callback){
		 
		//Ignore Difference of column
		Difference[1] = 0;
	   
		CreateAsyncFunctions([
			[
				//This function WILL increment position given by 1
				//Then return
				function(Params){
					//var IDX = 1;	
					
					var SubDifference = [0,0];
					var Difference = Params[0];
					
					SubDifference[0] = 
						(Difference[0]>=0?
						1:-1);
					
					
					//if(Differ)
					SubDifference[1] = 
						(Difference[1]>=0?
						1:-1);
					
					return SubDifference;
				}
				,
				[Difference]
				,
				//Logic function takes diff and subdiff
				//Subtract diff by subdiff
				function(Params){
					var IDX = 1;
				
					//Create Better SubDifference by time
					// MaxInterval / Current = placement
					
					var SubDifference = [Params[Params.length-3],
						Params[Params.length-2]
						];
					
					SubDifference[IDX] *= (parseInt(Params[0]/parseInt(Params[1])));
					
					
					//console.log("SD:"+SubDifference);
					var Difference = [Params[Params.length-5],
						Params[Params.length-4]];
					
					var This = Params[Params.length-3];
					
					if(SubDifference[IDX]<0){
						if(SubDifference[IDX]>=Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							
							return true;
						}
						else
							return false;
					}
					else if(SubDifference[IDX]>0){
						if(SubDifference[IDX]<=Difference[IDX]){
							
							This.TranslateAll(SubDifference,false,false);
							
							return true;
						}
						else
							return false;
					}
				}
				
				,
				
				this.Delay*1000,
				
				this.Delay,
				
				function(){
					console.log("FINISHED ANIMATION BY BOTH FOR SPRITE");
					
					Callback();
				
				}
				
			]
		]);
	};
	
	//Create 2D list of all Previous positions by iterating
	//ASCIIGRID and keeping less than that and my sub grid together
	//And also set the previous positions to EmptySpace
	
	//Then Starting From Pivot Position, first translate this
	//Then translate all other positions based off of Difference
	//neighbors
	//If ByRow is true, will start firt by row, then column
	//If ByColumn is true, start by column then row
	//If both are true, go directly to position with waits.
	this.TranslateAll = function (Difference,ByRow,ByColumn){
		
		ClearTable();
		
		console.log("TRANSLATE ALL BY DIFFERENCE:"+Difference);
		
		//Create three types of async
		if(ByRow==true && ByColumn==true){
			//Translate by both
			this.TranslateByBoth(Difference,function(){
				
			});
		}
		else if(ByRow==true){
			//Translate ByRow, then Translate By Column
			var F = function(This){
				
				This.TranslateByColumn(Difference,function(){
					
				
				},this);
			}
			this.TranslateByRow(Difference,	
				F
			,this);
		}
		else if(ByColumn==true){
			//Translate ByColumn, then Translate By Row
			var F = function(This){
				
				This.TranslateByRow(Difference,function(){
					
				
				},this);	
			}
			this.TranslateByColumn(Difference,
				F
			,this);
			
		}
		
		else{
		var Key;
		
		var Offset = SetOffset(this.PivotPosition,ASCIIGRID);
		
		console.log("OFFSET:"+Offset);
		
		//Create List of next positions
		var NextPositions = [];
		
		for(var i=0; 
		i<this.AllPivotPositions.length;i+=1){
			var E = this.AllPivotPositions[i][0];
			
			//Next
			var S = this.AllPivotPositions[i][1].split(",");
			var I = parseInt(S[0]) +Difference[0];
			var J = parseInt(S[1]) +Difference[1];
			
			//Relative
			var S2 = this.AllPivotPositions[i][2].split(",");
			var I2 = parseInt(S2[0]);
			var J2 = parseInt(S2[1]);
			
			NextPositions.push([E,I+","+J,I2+","+J2]);
		}
		
		console.log("NEXT POSITIONS:"+NextPositions);
		
		for(var i=0; i<NextPositions.length;i+=1){
			var ParentPrev;
			var Prev;
			
			//Prev Text Element
			var ParentPrev = NextPositions[i][0];
			if(ParentPrev)
				Prev = ParentPrev.childNodes[0];
			
			console.log("PARENT PREV:"+ParentPrev+" PREV:"+Prev);			
			//Next
			var S = NextPositions[i][1].split(",");
			var I = parseInt(S[0]);
			var J = parseInt(S[1]);
			var ParentNext;
			var Next;
			
			
			var ParentNext = document.getElementById(I+","+J);
			if(ParentNext)
				Next = ParentNext.childNodes[0];
			
		
			console.log("PARENT:"+ParentNext+" NEXT:"+Next);
			
			var Relative = NextPositions[i][2].split(",");
			
			var I2 = parseInt(Relative[0]);
			var J2 = parseInt(Relative[1]);
			
			var Value = this.ASCIIGRID[I2][J2];
			
			console.log("ACCESS:"+I2+","+J2+" VAL:"+Value);
			
			if(Next)
				UpdateValue(ParentNext,Next,
				this.ASCIIGRID
				[I2]
				[J2]	
				);
			
			//Check if not overwriting already written
			if(Prev)
				if(NotOverwriteNext(ParentPrev.id.split(","),NextPositions))
					UpdateValue(ParentPrev,Prev,EmptySpace);
			
			
		}
		
		this.AllPivotPositions = this.SetAllPositions();
		
		var FP = this.AllPivotPositions[0][1].split(",");
	
		this.PivotPosition = [parseInt(FP[0]),parseInt(FP[1])];
		
		}
		
	}
	
	
	
	//Private Static Function
	function ComputeDifference(P1,P2){
		return [P2[0]-P1[0],P2[1]-P1[1]];
	}
	
	// Private Static Vars are vars without this
	var PrivateVar1;
	
	//Otherwise they are public	
	//Pivot Position will be updates every transition
	this.PivotPosition = PivotPosition;
	this.ASCIIGRID = SubASCIIGrid;
	this.AVAILABLE = true;
	this.AllPivotPositions = this.SetAllPositions();
	this.Delay=Delay;
	//Public function callable from object Sprite
	//Translation Function from here to there
	//ex if translate from [0,0] to [10,20],
	//You will need to ComputeDifference(P1,P2)
	//Then, with this info, loop through all sprite pixels
	//
	this.Translate = function(P2,R,C){
		if(!P2)
			{
			return;
			}
		if(P2.length!=2)
			return;
		

		console.log("Translate");
		
		var Difference = ComputeDifference(this.PivotPosition,P2);
		
		//Now use async func
		//which waits by the delay set
		//and then calls TranslateAll
		//starts at pivot
		var R = false;
		var C = false;
		var S = document.getElementById("Select Movement Type");
		if(S.value.toLowerCase()=="row->column"){
			R = true;
		}
		else if(S.value.toLowerCase()=="column->row"){
			C = true;
		}
		
		this.TranslateAll(Difference,R,C);
	}
	
	console.log("Starting Position: "+this.PivotPosition);
	console.log("SUB ASCII GRID: ");
	PrettyPrintASCIIGrid(this.ASCIIGRID)
	    
	this.Translate(this.PivotPosition,false,false);
	
	};
</script>
</head>
<body>
<h1 class="CenterH1">ASCII ART ANIMATION</h1>

<!-- Table row maximizes all children of row  -->
<!--
<div class="Row">
<div class="Column" style="font-size:12px;">_</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
<div class="Column" style="font-size:3px;">t</div>
</div>
-->

<script type="text/javascript">

var Height = 10;
var Width = 20;

//Approximately, for every 1px in height, add 2 px in width
CreateGrid(Height,Width,1);

var Row = document.createElement("table");
Row.className="EnterRow";
var EnterCoordinates = InputPrompt2(
		Text("Enter Coordinates From: y,x"));
var TR1 = TableR(EnterCoordinates[0]);

Row.appendChild(TR1);

var EnterSprite = InputPrompt2(
		Text("Enter 2D Sprite Array [['X',..,],..,[]]"));
//var TR2 = document.createElement("tr");
TR1.appendChild(TableD(EnterSprite[0]));
Row.appendChild(TR1);

document.body.appendChild(Row);

//var Row2 = document.createElement("table");
//Row2.className="EnterRow";

var EnterAnimationCoordinates = InputPrompt2(
		Text("Enter Coordinates To: y,x"));

var TR2 = document.createElement("tr");
TR2.appendChild(TableD(EnterAnimationCoordinates[0]));
var SP = SelectionPrompt("Select Movement Type"
		,["row->column","column->row"]);
TR2.appendChild(SP[0]);
Row.appendChild(TR2);
//tionPrompt("",[]))

//R
//Row.appendChild()

//document.body.appendChild(Row);


EnterCoordinates[1].addEventListener("input",function(){
	var S = this.value.split(",");
	
	//ClearTable();
	
	if(ValidCoords(S)==true){
		if(!Sprite1)
			ForceEvent(document.getElementsByTagName("textarea")[1]);
		else{
			Sprite1.PivotPosition = [parseInt(S[0]),parseInt(S[1])];
		}
			
	}
	
});

EnterAnimationCoordinates[1].addEventListener("input",function(){
	var S = this.value.split(",");
	if(ValidCoords(S)==true){
		if(Sprite1)
			Sprite1.Translate(S,true,false);
	}
	
});

//EnterSprite[0].style.height="150px";
EnterSprite[1].style.height="150px";
EnterSprite[1].style.fontSize="1.5vw";

EnterSprite[1].addEventListener("input",function(){
	var Array;
	try{
	Array = eval(this.value);
	Array.push();
	console.log("ARRAY:"+Array);
	
	//Sprite1 = new Sprite([])
	
	
	var Coords = document.getElementsByTagName("textarea")[0].value.split(",");
	
	if(ValidCoords(Coords)==true){
		
		var Sprite2 = new Sprite(Coords,Array,500);
		
		if(Sprite1==null){
			//alert("New Sprite");
			Sprite1 = new Sprite(Coords,Array,500);
			//Sprite1.Translate([);
			//ClearTable();
			//Sprite1.Translate(Sprite1.PivotPosition);
		}
		else if(ArraysNotEqual(Sprite1.ASCIIGRID,Sprite2.ASCIIGRID)==true){
			//alert("New Sprite");
			
			delete Sprite1;
			
			Sprite1=Sprite2;
			//ClearTable();
			//Sprite1.Translate(Sprite1.PivotPosition);
		}
		else{
			//ClearTable();
			console.log("NOT UNIQUE: "+Sprite1.ASCIIGRID+"=="+Sprite2.ASCIIGRID);
		}
	}
	
	//ForceEvent(document.getElementsByClassName[0],"input");
	
	}
	catch(e){
		console.log(e+" Invalid ARRAY:"+this.value.split("\n").join(""));
	}
});

//Some testing
document.getElementById("5,5").innerHTML="a";

//var 

/*
Sprite1 = new Sprite([0,0],[
["*","-","*"],
["-","*","-"],
["*","-","*"]
],500);
*/

Sprite1 = new Sprite([0,0],[
	["8"]
	],500);

//Sprite1.Translate([5,5]);

</script>
</body>
</html>